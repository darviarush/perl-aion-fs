msgid "# NAME"
msgstr "# NAME"

msgid "Aion::Fs - утилиты для файловой системы: чтение, запись, поиск, замена файлов и т.д."
msgstr "Aion::Fs - utilities for the file system: reading, writing, searching, replacing files, etc."

msgid "0.0.6"
msgstr "0.0.6"

msgid "# DESCRIPTION"
msgstr "# DESCRIPTION"

msgid "Этот модуль облегчает использование файловой системы."
msgstr "This module makes it easier to use the file system."

msgid "Модули `File::Path`, `File::Slurper` и\n"
"`File::Find` обременены различными возможностями, которые используются редко, но требуют времени на ознакомление и тем самым повышают порог входа."
msgstr "Modules `File::Path`, `File::Slurper` and\n"
"`File::Find` is burdened with various features that are rarely used, but require time to become familiar with and thereby increase the barrier to entry."

msgid "В `Aion::Fs` же использован принцип программирования KISS - чем проще, тем лучше!"
msgstr "`Aion::Fs` uses the KISS programming principle - the simpler the better!"

msgid "Супермодуль `IO::All` не является конкурентом `Aion::Fs`, т.к. использует ООП подход, а `Aion::Fs` – ФП."
msgstr "The `IO::All` supermodule is not a competitor to `Aion::Fs`, because uses an OOP approach, and `Aion::Fs` is FP."

msgid "* ООП — объектно-ориентированное программирование.\n"
"* ФП — функциональное программирование."
msgstr "* OOP - object-oriented programming.\n"
"* FP - functional programming."

msgid "Считывает файл. Если параметр не указан, использует `$_`."
msgstr "Reads the file. If no parameter is specified, use `$_`."

msgid "`cat` читает со слоем `:utf8`. Но можно указать другой слой следующим образом:"
msgstr "`cat` reads with layer `:utf8`. But you can specify another layer like this:"

msgid "`cat` вызывает исключение в случае ошибки операции ввода-вывода:"
msgstr "`cat` throws an exception if the I/O operation fails:"

msgid ""
"* <File::Slurp> — `read_file('file.txt')`.\n"
"* <File::Slurper> — `read_text('file.txt')`, `read_binary('file.txt')`.\n"
"* <IO::All> — `io('file.txt') > $contents`.\n"
"* <IO::Util> — `$contents = ${ slurp 'file.txt' }`.\n"
"* <File::Util> — `File::Util->new->load_file(file => 'file.txt')`."
msgstr ""
"* <File::Slurp> - `read_file('file.txt')`.\n"
"* <File::Slurper> - `read_text('file.txt')`, `read_binary('file.txt')`.\n"
"* <IO::All> - `io('file.txt') > $contents`.\n"
"* <IO::Util> - `$contents = ${ slurp 'file.txt' }`.\n"
"* <File::Util> - `File::Util->new->load_file(file => 'file.txt')`."

msgid "Записывает `$content` в `$file`."
msgstr "Writes `$content` to `$file`."

msgid "* Если указан один параметр, использует `$_` вместо `$file`.\n"
"* `lay`, использует слой `:utf8`. Для указания иного слоя используется массив из двух элементов в параметре `$file`:"
msgstr "* If one parameter is specified, use `$_` instead of `$file`.\n"
"* `lay`, uses the `:utf8` layer. To specify a different layer, use an array of two elements in the `$file` parameter:"

msgid ""
"* <File::Slurp> — `write_file('file.txt', $contents)`.\n"
"* <File::Slurper> — `write_text('file.txt', $contents)`, `write_binary('file.txt', $contents)`.\n"
"* <IO::All> — `io('file.txt') < $contents`.\n"
"* <IO::Util> — `slurp \\$contents, 'file.txt'`.\n"
"* <File::Util> — `File::Util->new->write_file(file => 'file.txt', content => $contents, bitmask => 0644)`."
msgstr ""
"* <File::Slurp> - `write_file('file.txt', $contents)`.\n"
"* <File::Slurper> - `write_text('file.txt', $contents)`, `write_binary('file.txt', $contents)`.\n"
"* <IO::All> - `io('file.txt') < $contents`.\n"
"* <IO::Util> - `slurp \\$contents, 'file.txt'`.\n"
"* <File::Util> - `File::Util->new->write_file(file => 'file.txt', content => $contents, bitmask => 0644)`."

msgid "Рекурсивно обходит и возвращает пути из указанного пути или путей, если `$path` является ссылкой на массив. Без параметров использует `$_` как `$path`."
msgstr "Recursively traverses and returns paths from the specified path or paths if `$path` is an array reference. Without parameters, uses `$_` as `$path`."

msgid "Фильтры могут быть:"
msgstr "Filters can be:"

msgid ""
"* Подпрограммой — путь к текущему файлу передаётся в `$_`, а подпрограмма должна вернуть истину или ложь, как они понимаются perl-ом.\n"
"* Regexp — тестирует каждый путь регулярным выражением.\n"
"* Строка в виде \"-Xxx\", где `Xxx` — один или несколько символов. Аналогична операторам perl-а для тестирования файлов. Пример: `-fr` проверяет путь файловыми тестировщиками [-f и -r](https://perldoc.perl.org/functions/-X).\n"
"* Остальные строки превращаются функцией `wildcard` (см. ниже) в регулярное выражение для проверки каждого пути."
msgstr ""
"* By subroutine - the path to the current file is passed to `$_`, and the subroutine must return true or false, as understood by Perl.\n"
"* Regexp - tests each path with a regular expression.\n"
"* String in the form \"-Xxx\", where `Xxx` is one or more characters. Similar to Perl operators for testing files. Example: `-fr` checks the path with file testers [-f and -r](https://perldoc.perl.org/functions/-X).\n"
"* The remaining lines are turned by the `wildcard` function (see below) into a regular expression to test each path."

msgid "Пути, не прошедшие проверку `@filters`, не возвращаются."
msgstr "Paths that fail the `@filters` check are not returned."

msgid "Если фильтр -X не является файловой функцией perl, то выбрасывается исключение:"
msgstr "If the -X filter is not a perl file function, an exception is thrown:"

msgid "В этом примере `find` не может войти в подкаталог и передаёт ошибку в функцию `errorenter` (см. ниже) с установленными переменными `$_` и `$!` (путём к каталогу и сообщением ОС об ошибке)."
msgstr "In this example, `find` cannot enter the subdirectory and passes an error to the `errorenter` function (see below) with the `$_` and `$!` variables set (to the directory path and the OS error message)."

msgid "**Внимание!** Если `errorenter` не указана, то все ошибки **игнорируются**!"
msgstr "**Attention!** If `errorenter` is not specified, then all errors are **ignored**!"

msgid ""
"* <AudioFile::Find> — ищет аудиофайлы в указанной директории. Позволяет фильтровать их по атрибутам: названию, артисту, жанру, альбому и трэку.\n"
"* <Directory::Iterator> — `$it = Directory::Iterator->new($dir, %opts); push @paths, $_ while <$it>`.\n"
"* <IO::All> — `@paths = map { \"$_\" } grep { -f $_ && $_->size > 10*1024 } io(\".\")->all(0)`.\n"
"* <IO::All::Rule> — `$next = IO::All::Rule->new->file->size(\">10k\")->iter($dir1, $dir2); push @paths, \"$f\" while $f = $next->()`.\n"
"* <File::Find> — `find( sub { push @paths, $File::Find::name if /\\.png/ }, $dir )`.\n"
"* <File::Find::utf8> — как <File::Find>, только пути файлов в _utf8_.\n"
"* <File::Find::Age> — сортирует файлы по времени модификации (наследует <File::Find::Rule>): `File::Find::Age->in($dir1, $dir2)`.\n"
"* <File::Find::Declare> — `@paths = File::Find::Declare->new({ size => '>10K', perms => 'wr-wr-wr-', modified => '<2010-01-30', recurse => 1, dirs => [$dir1] })->find`.\n"
"* <File::Find::Iterator> — имеет ООП интерфейс с итератором и функции `imap` и `igrep`.\n"
"* <File::Find::Match> — вызывает обработчик на каждый подошедший фильтр. Похож на `switch`.\n"
"* <File::Find::Node> — обходит иерархию файлов параллельно несколькими процессами: `tie @paths, IPC::Shareable, { key => \"GLUE STRING\", create => 1 }; File::Find::Node->new(\".\")->process(sub { my $f = shift; $f->fork(5); tied(@paths)->lock; push @paths, $f->path; tied(@paths)->unlock })->find; tied(@paths)->remove`.\n"
"* <File::Find::Fast> — `@paths = @{ find($dir) }`.\n"
"* <File::Find::Object> — имеет ООП интерфейс с итератором.\n"
"* <File::Find::Parallel> — умеет сравнивать два каталога и возвращать их объединение, пересечение и количественное пересечение.\n"
"* <File::Find::Random> — выбирает файл или директорию наугад из иерархии файлов.\n"
"* <File::Find::Rex> — `@paths = File::Find::Rex->new(recursive => 1, ignore_hidden => 1)->query($dir, qr/^b/i)`.\n"
"* <File::Find::Rule> — `@files = File::Find::Rule->any( File::Find::Rule->file->name('*.mp3', '*.ogg')->size('>2M'), File::Find::Rule->empty )->in($dir1, $dir2);`. Имеет итератор, процедурный интерфейс и расширения [::ImageSize](File::Find::Rule::ImageSize) и [::MMagic](File::Find::Rule::MMagic): `@images = find(file => magic => 'image/*', '!image_x' => '>20', in => '.')`.\n"
"* <File::Find::Wanted> — `@paths = find_wanted( sub { -f && /\\.png/ }, $dir )`.\n"
"* <File::Hotfolder> — `watch( $dir, callback => sub { push @paths, shift } )->loop`. Работает на `AnyEvent`. Настраиваемый. Есть распараллеливание на несколько процессов.\n"
"* <File::Mirror> — формирует так же параллельный путь для копирования файлов: `recursive { my ($src, $dst) = @_; push @paths, $src } '/path/A', '/path/B'`.\n"
"* <File::Set> — `$fs = File::Set->new; $fs->add($dir); @paths = map { $_->[0] } $fs->get_path_list`.\n"
"* <File::Wildcard> — `$fw = File::Wildcard->new(exclude => qr/.svn/, case_insensitive => 1, sort => 1, path => \"src///*.cpp\", match => qr(^src/(.*?)\\.cpp$), derive => ['src/$1.o','src/$1.hpp']); push @paths, $f while $f = $fw->next`.\n"
"* <File::Wildcard::Find> — `findbegin($dir); push @paths, $f while $f = findnext()` или  `findbegin($dir); @paths = findall()`.\n"
"* <File::Util> — `File::Util->new->list_dir($dir, qw/ --pattern=\\.txt$ --files-only --recurse /)`.\n"
"* <Path::Find> — `@paths = path_find( $dir, \"*.png\" )`. Для сложных запросов использует _matchable_: `my $sub = matchable( sub { my( $entry, $directory, $fullname, $depth ) = @_; $depth <= 3 }`.\n"
"* <Path::Extended::Dir> — `@paths = Path::Extended::Dir->new($dir)->find('*.txt')`.\n"
"* <Path::Iterator::Rule> — `$i = Path::Iterator::Rule->new->file; @paths = $i->clone->size(\">10k\")->all(@dirs); $i->size(\"<10k\")...`.\n"
"* <Path::Class::Each> — `dir($dir)->each(sub { push @paths, \"$_\" })`.\n"
"* <Path::Class::Iterator> — `$i = Path::Class::Iterator->new(root => $dir, depth => 2); until ($i->done) { push @paths, $i->next->stringify }`.\n"
"* <Path::Class::Rule> — `@paths = Path::Class::Rule->new->file->size(\">10k\")->all($dir)`."
msgstr ""
"* <AudioFile::Find> - searches for audio files in the specified directory. Allows you to filter them by attributes: title, artist, genre, album and track.\n"
"* <Directory::Iterator> - `$it = Directory::Iterator->new($dir, %opts); push @paths, $_ while <$it>`.\n"
"* <IO::All> - `@paths = map { \"$_\" } grep { -f $_ && $_->size > 10*1024 } io(\".\")->all(0)`.\n"
"* <IO::All::Rule> - `$next = IO::All::Rule->new->file->size(\">10k\")->iter($dir1, $dir2); push @paths, \"$f\" while $f = $next->()`.\n"
"* <File::Find> - `find( sub { push @paths, $File::Find::name if /\\.png/ }, $dir )`.\n"
"* <File::Find::utf8> - like <File::Find>, only file paths are in _utf8_.\n"
"* <File::Find::Age> - sorts files by modification time (inherits <File::Find::Rule>): `File::Find::Age->in($dir1, $dir2)`.\n"
"* <File::Find::Declare> — `@paths = File::Find::Declare->new({ size => '>10K', perms => 'wr-wr-wr-', modified => '<2010-01-30', recurse => 1, dirs => [$dir1] })->find`.\n"
"* <File::Find::Iterator> - has an OOP interface with an iterator and the `imap` and `igrep` functions.\n"
"* <File::Find::Match> - calls a handler for each matching filter. Similar to `switch`.\n"
"* <File::Find::Node> - traverses the file hierarchy in parallel by several processes: `tie @paths, IPC::Shareable, { key => \"GLUE STRING\", create => 1 }; File::Find::Node->new(\".\")->process(sub { my $f = shift; $f->fork(5); tied(@paths)->lock; push @paths, $ f->path; tied(@paths)->unlock })->find; tied(@paths)->remove`.\n"
"* <File::Find::Fast> - `@paths = @{ find($dir) }`.\n"
"* <File::Find::Object> - has an OOP interface with an iterator.\n"
"* <File::Find::Parallel> - can compare two directories and return their union, intersection and quantitative intersection.\n"
"* <File::Find::Random> - selects a file or directory at random from the file hierarchy.\n"
"* <File::Find::Rex> - `@paths = File::Find::Rex->new(recursive => 1, ignore_hidden => 1)->query($dir, qr/^b/i) `.\n"
"* <File::Find::Rule> — `@files = File::Find::Rule->any( File::Find::Rule->file->name('*.mp3', '*.ogg ')->size('>2M'), File::Find::Rule->empty )->in($dir1, $dir2);`. Has an iterator, procedural interface, and [::ImageSize](File::Find::Rule::ImageSize) and [::MMagic](File::Find::Rule::MMagic) extensions: `@images = find(file => magic => 'image/*', '!image_x' => '>20', in => '.')`.\n"
"* <File::Find::Wanted> - `@paths = find_wanted( sub { -f && /\\.png/ }, $dir )`.\n"
"* <File::Hotfolder> - `watch( $dir, callback => sub { push @paths, shift } )->loop`. Powered by `AnyEvent`. Customizable. There is parallelization into several processes.\n"
"* <File::Mirror> - also forms a parallel path for copying files: `recursive { my ($src, $dst) = @_; push @paths, $src } '/path/A', '/path/B'`.\n"
"* <File::Set> - `$fs = File::Set->new; $fs->add($dir); @paths = map { $_->[0] } $fs->get_path_list`.\n"
"* <File::Wildcard> — `$fw = File::Wildcard->new(exclude => qr/.svn/, case_insensitive => 1, sort => 1, path => \"src///*.cpp \", match => qr(^src/(.*?)\\.cpp$), derive => ['src/$1.o','src/$1.hpp']); push @paths, $f while $f = $fw->next`.\n"
"* <File::Wildcard::Find> - `findbegin($dir); push @paths, $f while $f = findnext()` or `findbegin($dir); @paths = findall()`.\n"
"* <File::Util> - `File::Util->new->list_dir($dir, qw/ --pattern=\\.txt$ --files-only --recurse /)`.\n"
"* <Path::Find> - `@paths = path_find( $dir, \"*.png\" )`. For complex queries, use _matchable_: `my $sub = matchable( sub { my( $entry, $directory, $fullname, $depth ) = @_; $depth <= 3 }`.\n"
"* <Path::Extended::Dir> - `@paths = Path::Extended::Dir->new($dir)->find('*.txt')`.\n"
"* <Path::Iterator::Rule> - `$i = Path::Iterator::Rule->new->file; @paths = $i->clone->size(\">10k\")->all(@dirs); $i->size(\"<10k\")...`.\n"
"* <Path::Class::Each> - `dir($dir)->each(sub { push @paths, \"$_\" })`.\n"
"* <Path::Class::Iterator> - `$i = Path::Class::Iterator->new(root => $dir, depth => 2); until ($i->done) { push @paths, $i->next->stringify }`.\n"
"* <Path::Class::Rule> - `@paths = Path::Class::Rule->new->file->size(\">10k\")->all($dir)`."

msgid "Говорит `find` не входить в каталоги соответствующие фильтрам за ним."
msgstr "Tells `find` not to enter directories matching the filters behind it."

msgid "Вызывает `&block` для каждой ошибки возникающей при невозможности войти в какой-либо каталог."
msgstr "Calls `&block` for every error that occurs when a directory cannot be entered."

msgid "Останавливает `find` будучи вызван в одном из его фильтров, `errorenter` или `noenter`."
msgstr "Stops `find` being called in one of its filters, `errorenter` or `noenter`."

msgid "## erase (@paths)"
msgstr "## erase (@paths)"

msgid "Удаляет файлы и пустые каталоги. Возвращает `@paths`. При ошибке ввода-вывода выбрасывает исключение."
msgstr "Removes files and empty directories. Returns `@paths`. If there is an I/O error, it throws an exception."

msgid ""
"* <unlink> + <rmdir>.\n"
"* <File::Path> — `remove_tree(\"dir\")`.\n"
"* <File::Path::Tiny> — `File::Path::Tiny::rm($path)`. Не выбрасывает исключений."
msgstr ""
"* <unlink> + <rmdir>.\n"
"* <File::Path> - `remove_tree(\"dir\")`.\n"
"* <File::Path::Tiny> - `File::Path::Tiny::rm($path)`. Does not throw exceptions."

msgid "Заменяет каждый файл на `$_`, если его изменяет `&sub`. Возвращает файлы, в которых не было замен."
msgstr "Replaces each file with `$_` if it is modified by `&sub`. Returns files that have no replacements."

msgid "`@files` может содержать массивы из двух элементов. Первый рассматривается как путь, а второй — как слой. Слой по умолчанию — `:utf8`."
msgstr "`@files` can contain arrays of two elements. The first is treated as a path and the second as a layer. The default layer is `:utf8`."

msgid "`&sub` вызывается для каждого файла из `@files`. В неё передаются:"
msgstr "`&sub` is called for each file in `@files`. It transmits:"

msgid ""
"* `$_` — содержимое файла.\n"
"* `$a` — путь к файлу.\n"
"* `$b` — слой которым был считан файл и которым он будет записан."
msgstr ""
"* `$_` - file contents.\n"
"* `$a` — path to the file.\n"
"* `$b` — the layer by which the file was read and by which it will be written."

msgid "В примере ниже файл \"replace.ex\" считывается слоем `:utf8`, а записывается слоем `:raw` в функции `replace`:"
msgstr "In the example below, the file \"replace.ex\" is read by the `:utf8` layer and written by the `:raw` layer in the `replace` function:"

msgid ""
"* <File::Edit>.\n"
"* <File::Edit::Portable>.\n"
"* <File::Replace>.\n"
"* <File::Replace::Inplace>."
msgstr ""
"* <File::Edit>.\n"
"* <File::Edit::Portable>.\n"
"* <File::Replace>.\n"
"* <File::Replace::Inplace>."

msgid "Как **mkdir -p**, но считает последнюю часть пути (после последней косой черты) именем файла и не создаёт её каталогом. Без параметра использует `$_`."
msgstr "Like **mkdir -p**, but considers the last part of the path (after the last slash) to be a filename and does not create it as a directory. Without a parameter, uses `$_`."

msgid ""
"* Если `$path` не указан, использует `$_`.\n"
"* Если `$path` является ссылкой на массив, тогда используется путь в качестве первого элемента и права в качестве второго элемента.\n"
"* Права по умолчанию — `0755`.\n"
"* Возвращает `$path`."
msgstr ""
"* If `$path` is not specified, use `$_`.\n"
"* If `$path` is an array reference, then the path is used as the first element and rights as the second element.\n"
"* The default permission is `0755`.\n"
"* Returns `$path`."

msgid "* <File::Path> — `mkpath(\"dir1/dir2\")`.\n"
"* <File::Path::Tiny> — `File::Path::Tiny::mk($path)`. Не выбрасывает исключений."
msgstr "* <File::Path> - `mkpath(\"dir1/dir2\")`.\n"
"* <File::Path::Tiny> - `File::Path::Tiny::mk($path)`. Does not throw exceptions."

msgid "Время модификации `$path` в unixtime с дробной частью (из `Time::HiRes::stat`). Без параметра использует `$_`."
msgstr "Modification time of `$path` in unixtime with fractional part (from `Time::HiRes::stat`). Without a parameter, uses `$_`."

msgid ""
"* `-M` — `-M \"file.txt\"`, `-M _` в днях от текущего времени.\n"
"* <stat> — `(stat \"file.txt\")[9]` в секундах (unixtime).\n"
"* <Time::HiRes> — `(Time::HiRes::stat \"file.txt\")[9]` в секундах с дробной частью."
msgstr ""
"* `-M` — `-M \"file.txt\"`, `-M _` in days from the current time.\n"
"* <stat> - `(stat \"file.txt\")[9]` in seconds (unixtime).\n"
"* <Time::HiRes> - `(Time::HiRes::stat \"file.txt\")[9]` in seconds with fractional part."

msgid "Возвращает статистику о файле. Без параметра использует `$_`."
msgstr "Returns statistics about the file. Without a parameter, uses `$_`."

msgid "Чтобы можно было использовать с другими файловыми функциями, может получать ссылку на массив из которого берёт первый элемент в качестве файлового пути."
msgstr "To be used with other file functions, it can receive a reference to an array from which it takes the first element as the file path."

msgid "Выбрасывает исключение, если файл не существует или нет прав:"
msgstr "Throws an exception if the file does not exist or does not have permission:"

msgid ""
"* <Fcntl> – содержит константы для распознавания режима.\n"
"* <BSD::stat> – дополнительно возвращает atime, ctime и mtime в наносекундах, флаги пользователя и номер генерации файла. Имеет ООП-интерфейс.\n"
"* <File::chmod> – `chmod(\"o=,g-w\",\"file1\",\"file2\")`, `@newmodes = getchmod(\"+x\",\"file1\",\"file2\")`.\n"
"* <File::stat> – предоставляет ООП-интерфейс к stat.\n"
"* <File::Stat::Bits> – аналогичен <Fcntl>.\n"
"* <File::stat::Extra> – расширяет <File::stat> методами для получения информации о режиме, а так же перезагружает **-X**, **<=>**, **cmp** и **~~** операторы и стрингифицируется.\n"
"* <File::Stat::Ls> – возвращает режим в формате утилиты ls.\n"
"* <File::Stat::Moose> – ООП интерфейс на Moose.\n"
"* <File::Stat::OO> – предоставляет ООП-интерфейс к stat. Может возвращать atime, ctime и mtime сразу в `DateTime`.\n"
"* <File::Stat::Trigger> – следилка за изменением атрибутов файла.\n"
"* <Linux::stat> – парсит /proc/stat и возвращает доп-информацию. Однако в других ОС не работает.\n"
"* <Stat::lsMode> – возвращает режим в формате утилиты ls.\n"
"* <VMS::Stat> – возвращает списки VMS ACL."
msgstr ""
"* <Fcntl> – contains constants for mode recognition.\n"
"* <BSD::stat> - optionally returns atime, ctime and mtime in nanoseconds, user flags and file generation number. Has an OOP interface.\n"
"* <File::chmod> – `chmod(\"o=,g-w\",\"file1\",\"file2\")`, `@newmodes = getchmod(\"+x\",\"file1\",\"file2\")`.\n"
"* <File::stat> – provides an OOP interface to stat.\n"
"* <File::Stat::Bits> – similar to <Fcntl>.\n"
"* <File::stat::Extra> – extends <File::stat> with methods to obtain information about the mode, and also reloads **-X**, **<=>**, **cmp** and **~~** operators and stringified.\n"
"* <File::Stat::Ls> – returns the mode in the format of the ls utility.\n"
"* <File::Stat::Moose> – OOP interface for Moose.\n"
"* <File::Stat::OO> – provides an OOP interface to stat. Can return atime, ctime and mtime at once in `DateTime`.\n"
"* <File::Stat::Trigger> – monitors changes in file attributes.\n"
"* <Linux::stat> – parses /proc/stat and returns additional information. However, it does not work on other OSes.\n"
"* <Stat::lsMode> – returns the mode in the format of the ls utility.\n"
"* <VMS::Stat> – returns VMS ACLs."

msgid "Разбивает файловый путь на составляющие или собирает его из составляющих."
msgstr "Splits a file path into its components or assembles it from its components."

msgid ""
"* Если получает ссылку на массив, то воспринимает его первый элемент как путь.\n"
"* Если получает ссылку на хэш, то собирает из него путь. Незнакомые ключи просто игнорирует. Так же игнорирует volume в UNIX.\n"
"* К файловой системе не обращается."
msgstr ""
"* If it receives a reference to an array, it treats its first element as a path.\n"
"* If it receives a link to a hash, it collects a path from it. Unfamiliar keys are simply ignored. Also ignores volume on UNIX.\n"
"* The file system is not accessed."

msgid ""
"* <File::Spec> – `($volume, $directories, $file) = File::Spec->splitpath($path)`.\n"
"* <File::Basename> – `($name, $path, $suffix) = fileparse($fullname, @suffixlist)`.\n"
"* <Path::Class::File> – `file('foo', 'bar.txt')->is_absolute`.\n"
"* <Path::Extended::File> – `Path::Extended::File->new('path/to/file')->basename`.\n"
"* <Parse::Path> – `Parse::Path->new(path => 'gophers[0].food.count', style => 'DZIL')->push(\"chunk\")`. Работает с путями как с массивами (`push`, `pop`, `shift`, `splice`). Так же перегружает операторы сравнения. У него есть стили: `DZIL`, `File::Unix`, `File::Win32`, `PerlClass` и `PerlClassUTF8`."
msgstr ""
"* <File::Spec> – `($volume, $directories, $file) = File::Spec->splitpath($path)`.\n"
"* <File::Basename> – `($name, $path, $suffix) = fileparse($fullname, @suffixlist)`.\n"
"* <Path::Class::File> – `file('foo', 'bar.txt')->is_absolute`.\n"
"* <Path::Extended::File> – `Path::Extended::File->new('path/to/file')->basename`.\n"
"* <Parse::Path> – `Parse::Path->new(path => 'gophers[0].food.count', style => 'DZIL')->push(\"chunk\")`. Works with paths as with arrays (`push`, `pop`, `shift`, `splice`). It also overloads comparison operators. It has styles: `DZIL`, `File::Unix`, `File::Win32`, `PerlClass` and `PerlClassUTF8`."

msgid "Подключает `$pkg` (если он ещё не был подключён через `use` или `require`) и возвращает его. Без параметра использует `$_`."
msgstr "Connects `$pkg` (if it has not already been connected via `use` or `require`) and returns it. Without a parameter, uses `$_`."

msgid "Файл lib/A.pm:"
msgstr "lib/A.pm file:"

msgid "Файл lib/N.pm:"
msgstr "lib/N.pm file:"

msgid "## catonce (;$file)"
msgstr "## catonce (;$file)"

msgid "Считывает файл в первый раз. Любая последующая попытка считать этот файл возвращает `undef`. Используется для вставки модулей js и css в результирующий файл. Без параметра использует `$_`."
msgstr "Reads the file for the first time. Any subsequent attempt to read this file returns `undef`. Used to insert js and css modules into the resulting file. Without a parameter, uses `$_`."

msgid "* `$file` может содержать массивы из двух элементов. Первый рассматривается как путь, а второй — как слой. Слой по умолчанию — `:utf8`.\n"
"* Если `$file` не указан – использует `$_`."
msgstr "* `$file` can contain arrays of two elements. The first is treated as a path and the second as a layer. The default layer is `:utf8`.\n"
"* If `$file` is not specified, use `$_`."

msgid "## wildcard (;$wildcard)"
msgstr "## wildcard (;$wildcard)"

msgid "Переводит файловую маску в регулярное выражение. Без параметра использует `$_`."
msgstr "Converts a file mask to a regular expression. Without a parameter, uses `$_`."

msgid ""
"* `**` - `[^/]*`\n"
"* `*` - `.*`\n"
"* `?` - `.`\n"
"* `??` - `[^/]`\n"
"* `{` - `(`\n"
"* `}` - `)`\n"
"* `,` - `|`\n"
"* Остальные символы экранируются с помощью `quotemeta`."
msgstr ""
"* `**` - `[^/]*`\n"
"* `*` - `.*`\n"
"* `?` - `.`\n"
"* `??` - `[^/]`\n"
"* `{` - `(`\n"
"* `}` - `)`\n"
"* `,` - `|`\n"
"* Other characters are escaped using `quotemeta`."

msgid "Используется в фильтрах функции `find`."
msgstr "Used in filters of the `find` function."

msgid "**См. также:**"
msgstr "**Cm. Also:**"

msgid ""
"* <File::Wildcard>.\n"
"* <String::Wildcard::Bash>.\n"
"* <Text::Glob> — `glob_to_regex(\"*.{pm,pl}\")`."
msgstr ""
"* <File::Wildcard>.\n"
"* <String::Wildcard::Bash>.\n"
"* <Text::Glob> - `glob_to_regex(\"*.{pm,pl}\")`."

msgid "Открывает файл в редакторе из .config на указанной строке. По умолчанию использует `vscodium %p:%l`."
msgstr "Opens the file in the editor from .config at the specified line. Defaults to `vscodium %p:%l`."

msgid "Файл .config.pm:"
msgstr ".config.pm file:"

msgid "## from_pkg (;$pkg)"
msgstr "## from_pkg (;$pkg)"

msgid "Переводит пакет в путь ФС. Без параметра использует `$_`."
msgstr "Transfers the packet to the FS path. Without a parameter, uses `$_`."

msgid "## to_pkg (;$path)"
msgstr "## to_pkg (;$path)"

msgid "Переводит путь из ФС в пакет. Без параметра использует `$_`."
msgstr "Translates the path from the FS to the package. Without a parameter, uses `$_`."

msgid "# AUTHOR"
msgstr "#AUTHOR"

msgid "Yaroslav O. Kosmina <dart@cpan.org>"
msgstr "Yaroslav O. Kosmina <dart@cpan.org>"

msgid "⚖ **GPLv3**"
msgstr "⚖ **GPLv3**"

msgid "The Aion::Fs is copyright © 2023 by Yaroslav O. Kosmina. Rusland. All rights reserved."
msgstr "The Aion::Fs is copyright © 2023 by Yaroslav O. Kosmina. Rusland. All rights reserved."

